# -*- coding: utf-8 -*-
"""Copy of p7_CD.ipynb

Automatically generated by Colab.

Original file is located at
"""

class ReachingDefinitions:
    def __init__(self):
        self.blocks = {}
        self.flow_graph = []
        self.gen = {}
        self.kill = {}
        self.in_set = {}
        self.out_set = {}
        self.all_definitions = set()

    def parse_blocks(self, block_contents):
        self.blocks = block_contents

        for block_id, statements in self.blocks.items():
            for stmt in statements:
                if '=' in stmt:
                    self.all_definitions.add(stmt.strip())

    def compute_gen_kill(self):
        """
        Compute GEN and KILL sets for each block
        GEN[B] = definitions generated in block B
        KILL[B] = definitions killed by block B (other definitions of same variable)
        """
        def get_variable(definition):
            if ':' in definition:
                definition = definition.split(':', 1)[1]
            return definition.split('=')[0].strip()

        for block_id, statements in self.blocks.items():
            self.gen[block_id] = set()
            self.kill[block_id] = set()

            for stmt in statements:
                if '=' in stmt:
                    self.gen[block_id].add(stmt.strip())


            for gen_def in self.gen[block_id]:
                gen_var = get_variable(gen_def)
                for other_def in self.all_definitions:
                    other_var = get_variable(other_def)
                    if gen_var == other_var and gen_def != other_def:
                        self.kill[block_id].add(other_def)

    def compute_reaching_definitions(self, flow_graph, entry_block):
        """
        Compute reaching definitions using iterative algorithm
        flow_graph: adjacency matrix or list of edges
        entry_block: starting block
        """
        self.flow_graph = flow_graph

        for block_id in self.blocks.keys():
            self.in_set[block_id] = set()
            self.out_set[block_id] = self.gen[block_id].copy()

        predecessors = self.get_predecessors(flow_graph)

        iteration = 0
        changed = True

        print("=" * 80)
        print("INITIAL VALUES")
        print("=" * 80)
        self.print_iteration(iteration)

        while changed:
            iteration += 1
            changed = False

            print("\n" + "=" * 80)
            print(f"ITERATION {iteration}")
            print("=" * 80)

            for block_id in self.blocks.keys():
                old_in = self.in_set[block_id].copy()
                self.in_set[block_id] = set()

                if block_id in predecessors:
                    for pred in predecessors[block_id]:
                        self.in_set[block_id] = self.in_set[block_id].union(self.out_set[pred])

                old_out = self.out_set[block_id].copy()
                self.out_set[block_id] = self.gen[block_id].union(
                    self.in_set[block_id] - self.kill[block_id]
                )

                if old_in != self.in_set[block_id] or old_out != self.out_set[block_id]:
                    changed = True

            self.print_iteration(iteration)


        print("\n" + "=" * 80)
        print("FINAL RESULT")
        print("=" * 80)
        self.print_final_results()

    def get_predecessors(self, flow_graph):
        """
        Build predecessor list from flow graph
        flow_graph can be adjacency matrix or edge list
        """
        predecessors = {}

        if isinstance(flow_graph, list) and isinstance(flow_graph[0], list):
            blocks = list(self.blocks.keys())
            for i, row in enumerate(flow_graph):
                for j, connected in enumerate(row):
                    if connected:
                        if blocks[j] not in predecessors:
                            predecessors[blocks[j]] = []
                        predecessors[blocks[j]].append(blocks[i])

        elif isinstance(flow_graph, list) and isinstance(flow_graph[0], tuple):
            for from_block, to_block in flow_graph:
                if to_block not in predecessors:
                    predecessors[to_block] = []
                predecessors[to_block].append(from_block)

        return predecessors

    def print_iteration(self, iteration):
        """Print the state at current iteration"""
        print(f"\nIteration: {iteration}")
        print("-" * 160)

        for block_id in sorted(self.blocks.keys()):
            print(f"\nBlock {block_id}:")
            print(f"  Statements: {self.blocks[block_id]}")
            print(f"  GEN:  {self.format_set(self.gen[block_id])}")
            print(f"  KILL: {self.format_set(self.kill[block_id])}")
            print(f"  IN:   {self.format_set(self.in_set[block_id])}")
            print(f"  OUT:  {self.format_set(self.out_set[block_id])}")

    def print_final_results(self):
        """Print final computed results in table format"""
        col_widths = [10, 50, 50, 50, 50]
        header = ["Block", "GEN", "KILL", "IN", "OUT"]
        print("\n{:<{w[0]}} {:<{w[1]}} {:<{w[2]}} {:<{w[3]}} {:<{w[4]}}".format(*header, w=col_widths))
        print("-" * sum(col_widths) + "-" * (len(col_widths) - 1) * 2)

        for block_id in sorted(self.blocks.keys()):
            print("{:<{w[0]}} {:<{w[1]}} {:<{w[2]}} {:<{w[3]}} {:<{w[4]}}".format(
                str(block_id),
                self.format_set(self.gen[block_id]),
                self.format_set(self.kill[block_id]),
                self.format_set(self.in_set[block_id]),
                self.format_set(self.out_set[block_id]),
                w=col_widths
            ))

    def format_set(self, s):
        """Format set for display, showing only definition labels"""
        if not s:
            return "{}"
        labels = []
        for definition in sorted(list(s)):
            if ':' in definition:
                labels.append(definition.split(':')[0].strip())
            else:
                labels.append(definition.strip())
        return "{" + ", ".join(labels) + "}"


def example1():

    print("EXAMPLE 1: Simple Loop Program")
    print("=" * 80)

    rd = ReachingDefinitions()

    block_contents = {
        'B1': ['d1: b = 1', 'd2: c = 2'],
        'B2': ['d3: a = b + c', 'd4: d = a - b'],
        'B3': ['d5: d = c + d'],
        'B4': ['d6: c = b + c', 'd7: e = a - b'],
        'B5': ['d8: d = b + c', 'd9: e = e + 1'],
        'B6': ['d10: b = c * d', 'd11: c = c - d']
    }


    flow_graph = [
        ('B1', 'B2'),
        ('B2', 'B3'),
        ('B2', 'B4'),
        ('B3', 'B4'),
        ('B3', 'B5'),
        ('B4', 'B2'),
        ('B4', 'B6'),
        ('B5', 'B3'),
    ]

    rd.parse_blocks(block_contents)
    rd.compute_gen_kill()
    rd.compute_reaching_definitions(flow_graph, 'B1')

def interactive_input():
    """
    Interactive mode for user input
    """
    print("\n\n" + "=" * 80)
    print("INTERACTIVE MODE")
    print("=" * 80)

    rd = ReachingDefinitions()

    num_blocks = int(input("\nEnter number of blocks: "))

    block_contents = {}

    for i in range(1, num_blocks + 1):
        block_id = f'B{i}'
        print(f"\nEnter statements for {block_id} (enter empty line to finish):")
        statements = []
        while True:
            stmt = input(f"  Statement: ").strip()
            if not stmt:
                break
            statements.append(stmt)
        block_contents[block_id] = statements

    print("\nEnter flow graph (enter edges as 'from to', empty line to finish):")
    print("Example: B1 B2")
    flow_graph = []
    while True:
        edge = input("  Edge: ").strip()
        if not edge:
            break
        from_block, to_block = edge.split()
        flow_graph.append((from_block, to_block))

    rd.parse_blocks(block_contents)
    rd.compute_gen_kill()
    rd.compute_reaching_definitions(flow_graph, 'B1')


if __name__ == "__main__":
    example1()

